##
# Universal Fan Controller (UFC) .init file creator
# Builder version
#
# Transfer information from Service Launcher to Service Runtime
# program, related to pass-thru global variables.
##

function update_launcher_init_file ()
{
	local key
	local permissions

	debug_print 1 "Generate new Launcher Service program initialization file: $service_launcher_init_filename"

	{
		printf "# Universal Fan Controller (UFC) auto-configuration file export\n"
		printf "# generated by Builder program\n"
		printf "# generated for Service Launcher program\n"
		printf "# program_version=\"%s\"\n" "$builder_program_version"
		printf "# this file created at %s\n" "$(build_date_time_string)"
	} >> "$service_launcher_init_filename"

	##
	# Copy or reset binary trackers before export.
	#
	# These binaries need to be seeded for the Service programs. The Service
	# Launcher will re-create active binaries on start-up in case fan activity has changed.
	#
	# Most fan header and zone binaries are static and do not get refreshed. Only the
	# active fan header/zone trackers may change, and need updating everytime the
	# Service is launched.
	##

	# transfer binaries
	{
		# preserve static universal fan and zone binaries
		printf "fan_header_binary=\"%s\"\n" "$fan_header_binary"
		printf "fan_zone_binary=\"%s\"\n" "$fan_zone_binary"

		# reset dynamic universal binaries
		printf "fan_header_active_binary=\"%s\"\n" "$(flush_binary "${#fan_header_active_binary}")"
		printf "fan_zone_active_binary=\"%s\"\n" "$(flush_binary "${#fan_zone_active_binary}")"

		# export binary length limiters
		printf "fan_zone_binary_length=\"%s\"\n" "$fan_zone_binary_length"
		printf "fan_header_binary_length=\"%s\"\n" "$fan_header_binary_length"

		# export type-specific fan header and zone binary strings
		for duty_type in "${fan_duty_category[@]}"; do # 1/

			# export fixed binaries as-is
			if declare -p "${duty_type}_fan_header_binary" &>/dev/null; then # 1/
				local -n pointer="${duty_type}_fan_header_binary"
				declare -p "${duty_type}_fan_header_binary" &>/dev/null && printf "${duty_type}_fan_header_binary=\"%s\"\n" "$pointer"
			fi # 1/

			if declare -p "${duty_type}_fan_zone_binary" &>/dev/null; then # 1/
				local -n pointer="${duty_type}_fan_zone_binary"
				declare -p "${duty_type}_fan_zone_binary" &>/dev/null && printf "${duty_type}_fan_zone_binary=\"%s\"\n" "$pointer"
			fi # 1/

			# reset active binaries before export
			if declare -p "${duty_type}_fan_header_active_binary" &>/dev/null; then # 1/
				local -n pointer="${duty_type}_fan_header_active_binary"
				pointer="$(flush_binary "${#pointer}")"
				printf "${duty_type}_fan_header_active_binary=\"%s\"\n" "$pointer"
			fi # 1/

			# duty category fan zone trackers are only relevant when fan control method is zoned
			if [ "$fan_control_method" = "zone" ]; then # 1/
				if declare -p "${duty_type}_fan_zone_active_binary" &>/dev/null; then # 2/
					local -n pointer="${duty_type}_fan_zone_active_binary"
					pointer="$(flush_binary "${#pointer}")"
					printf "${duty_type}_fan_zone_active_binary=\"%s\"\n" "$pointer"
				fi # 2/
			fi # 1/
		done # 1/
	} >> "$service_launcher_init_filename"

	{
		# program variables
		printf "program_name=\"%s\"\n" "$program_name"
		printf "server_id=\"%s\"\n" "$server_id"
		printf "service_name=\"%s\"\n" "$service_name"
		printf "service_program_version=\"%s\"\n" "$service_program_version"

		# motherboard metadata
		printf "mobo_manufacturer=\"%s\"\n" "$mobo_manufacturer"
		printf "mobo_model=\"%s\"\n" "$mobo_model"
		printf "mobo_gen=\"%s\"\n" "$mobo_gen"

		# cpu temp constraints
		printf "cpu_temp_low=%s\n" $((cpu_temp_low))
		printf "cpu_temp_med=%s\n" $((cpu_temp_med))
		printf "cpu_temp_high=%s\n" "$cpu_temp_high"
		printf "cpu_temp_override=%s\n" $((cpu_temp_override))

		# cpu fan constraints
		printf "fan_duty_min[cpu]=%s\n" $((fan_duty_min[cpu]))
		printf "fan_duty_low[cpu]=%s\n" $((fan_duty_low[cpu]))
		printf "cpu_fan_duty_med=%s\n" $((cpu_fan_duty_med))
		printf "cpu_fan_duty_high=%s\n" $((cpu_fan_duty_high))
		printf "cpu_fan_duty_max=%s\n" $((cpu_fan_duty_max))
		printf "cpu_fan_duty_start=%s\n" $((cpu_fan_duty_start))

		printf "fan_duty_limit=%s\n" $((fan_duty_limit))

		# cpu monitoring
		printf "cpu_temp_sensor=\"%s\"\n" "$cpu_temp_sensor"
		printf "cpu_temp_method=\"%s\"\n" "$cpu_temp_method"
		printf "cpu_fan_control=\"%s\"\n" "$cpu_fan_control"
		printf "only_cpu_fans=\"%s\"\n" "$only_cpu_fans"
		printf "numcpu=%s\n" $((numcpu))
		printf "cpu_temp_rolling_average_limit=%s\n" $((cpu_temp_rolling_average_limit))
		printf "debug_level=%s\n" $((debug_level))
		printf "log_to_syslog=\"%s\"\n" "$log_to_syslog"
		printf "device_temp_reader=\"%s\"\n" "$device_temp_reader"
		printf "ipmitool=\"%s\"\n" "$ipmitool"
		printf "include_ssd=\"%s\"\n" "$include_ssd"

		# misc controls
		printf "email_alerts=\"%s\"\n" "$email_alerts"
		printf "email=\"%s\"\n" "$email"

		# program logging parameters
		printf "log_hourly_alignment=\"%s\"\n" "$log_hourly_alignment"
		printf "log_hourly_interval=%s\n" $((log_hourly_interval))
		printf "log_age_max=%s\n" $((log_age_max))

		# JSON logging parameters
		printf "log_json_export=\"%s\"\n" "$log_json_export"
		printf "log_json_interval=%s\n" $((log_json_interval))
		printf "log_json_age_max=%s\n" $((log_json_age_max))

		# PID hard-coded constraints (user preferences from Builder config file)
		printf "pid_Kp=%s\n" "$pid_Kp"
		printf "pid_Ki=%s\n" "$pid_Ki"
		printf "pid_Kd=%s\n" "$pid_Kd"

		# device temp related
		printf "device_avg_temp_target=%s\n" $((device_avg_temp_target))
		printf "device_max_allowed_temp=%s\n" $((device_max_allowed_temp))

		printf "bmc_threshold_interval=%s\n" "$bmc_threshold_interval"
		printf "bmc_command_schema=\"%s\"\n" "$bmc_command_schema"
		printf "fan_control_method=\"%s\"\n" "$fan_control_method"

		printf "cpu_temp_polling_interval=%s\n" $((cpu_temp_polling_interval))
		printf "device_temp_polling_interval=%s\n" $((device_temp_polling_interval))

		# fan related operational variables
		printf "fan_speed_delay=%s\n" $((fan_speed_delay))

		# fan validation timers
		printf "cpu_fan_validation_delay=%s\n" $((cpu_fan_validation_delay))
		printf "device_fan_validation_delay=%s\n" $((device_fan_validation_delay))
		printf "suspicious_fan_validation_delay=%s\n" $((suspicious_fan_validation_delay))
		printf "all_fan_validation_delay=%s\n" $((all_fan_validation_delay))

		# pre-defined filenames for Service Launcher
		printf "service_launcher_manifest_filename=\"%s\"\n" "$service_launcher_manifest_target_filename"

		# pre-defined dirs and filenames for Service Runtime
		printf "service_runtime_dir=\"%s\"\n" "$service_runtime_target_dir"
		printf "service_runtime_filename=\"%s\"\n" "$service_runtime_target_filename"
		printf "service_runtime_init_filename=\"%s\"\n" "$service_runtime_init_filename"
		printf "service_runtime_manifest_filename=\"%s\"\n" "$service_runtime_manifest_target_filename"
		printf "service_functions_dir=\"%s\"\n" "$service_functions_target_dir"

		# device related operational variables
		printf "device_list_old=\"%s\"\n" "$device_list"

		# logging variables
		printf "service_log_dir=\"%s\"\n" "$service_log_dir"
		printf "service_launcher_log_dir=\"%s\"\n" "$service_launcher_log_dir"
		printf "service_runtime_log_dir=\"%s\"\n" "$service_runtime_log_dir"
		printf "service_json_log_dir=\"%s\"\n" "$service_json_log_dir"

		# device fan constraints
		printf "fan_duty_min[default]=%s\n" $((device_fan_duty_min))
		printf "device_fan_duty_low=%s\n" $((device_fan_duty_low))
		printf "device_fan_duty_med=%s\n" $((device_fan_duty_med))
		printf "device_fan_duty_high=%s\n" $((device_fan_duty_high))
		printf "device_fan_duty_max=%s\n" $((device_fan_duty_max))
		printf "device_fan_duty_start=%s\n" $((device_fan_duty_start))

		# pass-thru variables (Builder --> Service Runtime)
		printf "device_polling_interval=%s\n" $((device_polling_interval))
		printf "ipmi_payload_byte_count=%s\n" $((ipmi_payload_byte_count))

		# CPU override byte required by some group fan management style BMC chips
		printf "cpu_fan_override=\"%s\"\n" "$cpu_fan_override"
	} >> "$service_launcher_init_filename"

	# arrays
	{
		for key in "${!fan_header_category[@]}"; do # 1/ fan_header_category[zone_id]=fan duty category
			printf "fan_header_category[$key]=\"%s\"\n" "${fan_header_category[$key]}"
		done # 1/

		for key in "${!fan_header_name[@]}"; do # 1/ fan_header_name[fan_id]=fan_name
			printf "fan_header_name[$key]=\"%s\"\n" "${fan_header_name[$key]}"
		done # 1/

		for key in "${!fan_header_id[@]}"; do # 1/ fan_header_id[fan_name]=fan_id
			printf "fan_header_id[$key]=\"%s\"\n" "${fan_header_id[$key]}"
		done # 1/

		for key in "${!ipmi_fan_write_order[@]}"; do # 1/ reference write order of fan header names based on BMC command schema
			printf "ipmi_fan_write_order[$key]=%s\n" "${ipmi_fan_write_order[$key]}"
		done # 1/

		for key in "${!ipmi_write_position_fan_id[@]}"; do # 1/ [write position]=fan id
			printf "ipmi_write_position_fan_id[$key]=\"%s\"\n" "${ipmi_write_position_fan_id[$key]}"
		done # 1/

		for key in "${!ipmi_fan_id_write_position[@]}"; do # 1/ [fan id]=write position
			printf "ipmi_fan_id_write_position[$key]=\"%s\"\n" "${ipmi_fan_id_write_position[$key]}"
		done # 1/

		for key in "${!ipmi_write_position_fan_name[@]}"; do # 1/ [write position]=fan name (direct and group fan control)
			printf "ipmi_write_position_fan_name[$key]=%s\n" "${ipmi_write_position_fan_name[$key]}"
		done # 1/

		for key in "${!ipmi_group_fan_payload[@]}"; do # 1/ [fan id]=new fan duty cycle
			printf "ipmi_group_fan_payload[$key]=%s\n" "${ipmi_group_fan_payload[$key]}"
		done # 1/

		for key in "${!fan_speed_limit_min[@]}"; do # 1/ skip invalid or unknown values
			(( ${fan_speed_limit_min[$key]} != 0 )) && printf "fan_speed_limit_min[$key]=%s\n" "${fan_speed_limit_min[$key]}"
		done # 1/

		for key in "${!fan_speed_limit_max[@]}"; do # 1/
			(( ${fan_speed_limit_max[$key]} != 0 )) && printf "fan_speed_limit_max[$key]=%s\n" "${fan_speed_limit_max[$key]}"
		done # 1/

		for key in "${!fan_speed_duty_low[@]}"; do # 1/
			(( ${fan_speed_duty_low[$key]} != 0 )) && printf "fan_speed_duty_low[$key]=%s\n" "${fan_speed_duty_low[$key]}"
		done # 1/

		for key in "${!fan_speed_duty_med[@]}"; do # 1/
			(( ${fan_speed_duty_med[$key]} != 0 )) && printf "fan_speed_duty_med[$key]=%s\n" "${fan_speed_duty_med[$key]}"
		done # 1/

		for key in "${!fan_speed_duty_high[@]}"; do # 1/
			(( ${fan_speed_duty_high[$key]} != 0 )) && printf "fan_speed_duty_high[$key]=%s\n" "${fan_speed_duty_high[$key]}"
		done # 1/

		for key in "${!fan_speed_duty_max[@]}"; do # 1/
			(( ${fan_speed_duty_max[$key]} != 0 )) && printf "fan_speed_duty_max[$key]=%s\n" "${fan_speed_duty_max[$key]}"
		done # 1/

		for key in "${!ipmi_sensor_column_cpu[@]}"; do # 1/
			printf "ipmi_sensor_column_cpu[$key]=\"%s\"\n" "${ipmi_sensor_column_cpu[$key]}"
		done # 1/

		for key in "${!ipmi_sensor_column_fan[@]}"; do # 1/
			printf "ipmi_sensor_column_fan[$key]=\"%s\"\n" "${ipmi_sensor_column_fan[$key]}"
		done # 1/

		for key in "${!ipmi_sdr_column_cpu[@]}"; do # 1/
			printf "ipmi_sdr_column_cpu[$key]=\"%s\"\n" "${ipmi_sdr_column_cpu[$key]}"
		done # 1/

		for key in "${!ipmi_sensor_column_cpu_temp[@]}"; do # 1/
			printf "ipmi_sensor_column_cpu_temp[$key]=\"%s\"\n" "${ipmi_sensor_column_cpu_temp[$key]}"
		done # 1/

		for key in "${!fan_speed_lnr[@]}"; do # 1/
			(( ${fan_speed_lnr[$key]} != 0 )) && printf "fan_speed_lnr[$key]=%s\n" "${fan_speed_lnr[$key]}"
		done # 1/

		for key in "${!fan_speed_lcr[@]}"; do # 1/
			(( ${fan_speed_lcr[$key]} != 0 )) && printf "fan_speed_lcr[$key]=%s\n" "${fan_speed_lcr[$key]}"
		done # 1/

		for key in "${!fan_speed_lnc[@]}"; do # 1/
			(( ${fan_speed_lnc[$key]} != 0 )) && printf "fan_speed_lnc[$key]=%s\n" "${fan_speed_lnc[$key]}"
		done # 1/

		for key in "${!fan_speed_unc[@]}"; do # 1/
			(( ${fan_speed_unc[$key]} != 0 )) && printf "fan_speed_unc[$key]=%s\n" "${fan_speed_unc[$key]}"
		done # 1/

		for key in "${!fan_speed_ucr[@]}"; do # 1/
			(( ${fan_speed_ucr[$key]} != 0 )) && printf "fan_speed_ucr[$key]=%s\n" "${fan_speed_ucr[$key]}"
		done # 1/

		for key in "${!fan_speed_unr[@]}"; do # 1/
			(( ${fan_speed_unr[$key]} != 0 )) && printf "fan_speed_unr[$key]=%s\n" "${fan_speed_unr[$key]}"
		done # 1/

		for key in "${!fan_header_zone[@]}"; do # 1/ maps each fan header id to its zone id
			printf "fan_header_zone[$key]=%s\n" "${fan_header_zone[$key]}"
		done # 1/
	} >> "$service_launcher_init_filename"

	# set Service user as file owner
	run_command "$service_username":"$(id -gn "$service_username")" "$service_launcher_init_filename"

	debug_print 3 "Restrict Service Launcher .init file permissions to read-only access for all users: $service_launcher_init_filename"

	! set_target_permissions "$service_launcher_init_filename" 444 && debug_level 3 caution "Failed to Restrict Service Launcher .init file permissions for an unknown reason"
}
